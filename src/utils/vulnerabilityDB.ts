import type { ServiceInfo } from './types';

interface Vulnerability {
  id: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  cvss: number;
  references: string[];
  published: string;
}

export class VulnerabilityDB {
  private static instance: VulnerabilityDB;
  private vulnerabilityCache: Map<string, Vulnerability[]>;
  private lastUpdate: Date;

  private constructor() {
    this.vulnerabilityCache = new Map();
    this.lastUpdate = new Date(0);
  }

  static getInstance(): VulnerabilityDB {
    if (!VulnerabilityDB.instance) {
      VulnerabilityDB.instance = new VulnerabilityDB();
    }
    return VulnerabilityDB.instance;
  }

  async searchVulnerabilities(service: ServiceInfo): Promise<Vulnerability[]> {
    const cacheKey = `${service.name}-${service.version}`;
    
    // Check cache first
    if (this.vulnerabilityCache.has(cacheKey)) {
      return this.vulnerabilityCache.get(cacheKey) || [];
    }

    try {
      // Fetch from NVD API
      const response = await fetch(
        `https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${encodeURIComponent(service.name)}`
      );

      if (!response.ok) {
        throw new Error('Failed to fetch vulnerability data');
      }

      const data = await response.json();
      
      // Process and filter vulnerabilities
      const vulnerabilities: Vulnerability[] = data.vulnerabilities
        .filter((v: any) => {
          const cpe = v.cve.configurations?.nodes?.[0]?.cpeMatch?.[0]?.criteria;
          return cpe?.includes(service.name.toLowerCase());
        })
        .map((v: any) => ({
          id: v.cve.id,
          description: v.cve.descriptions[0]?.value || '',
          severity: this.getCVSSSeverity(v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 0),
          cvss: v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 0,
          references: v.cve.references?.map((ref: any) => ref.url) || [],
          published: v.cve.published
        }));

      // Update cache
      this.vulnerabilityCache.set(cacheKey, vulnerabilities);
      this.lastUpdate = new Date();

      return vulnerabilities;
    } catch (error) {
      console.error('Error fetching vulnerabilities:', error);
      return [];
    }
  }

  private getCVSSSeverity(score: number): 'low' | 'medium' | 'high' | 'critical' {
    if (score >= 9.0) return 'critical';
    if (score >= 7.0) return 'high';
    if (score >= 4.0) return 'medium';
    return 'low';
  }

  async getVulnerabilityStats(vulnerabilities: Vulnerability[]): Promise<{
    total: number;
    bySeverity: Record<string, number>;
    averageCVSS: number;
  }> {
    const bySeverity = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };

    vulnerabilities.forEach(vuln => {
      bySeverity[vuln.severity]++;
    });

    const averageCVSS = vulnerabilities.reduce((acc, vuln) => acc + vuln.cvss, 0) / 
      (vulnerabilities.length || 1);

    return {
      total: vulnerabilities.length,
      bySeverity,
      averageCVSS
    };
  }
}